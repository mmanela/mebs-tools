{"version":3,"sources":["Theme.ts","stores/cardSortStore.ts","components/CardSort.tsx","stores/colorBoardStore.ts","components/ColorBoard.tsx","components/PageRouter.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GlobalTheme","global","colors","MebsDarkBlue","MebsLightBlue","MebsDarkYellow","MebsLightYellow","MebsDarkGray","MebsLightGray","font","family","size","height","breakpoints","xsmall","value","small","medium","large","xlarge","focus","border","color","button","active","default","primary","secondary","CardLocation","CardSortStore","stateMap","Map","config","this","has","name","get","state","cards","map","s","id","text","type","location","List","categories","set","instance","StyledCard","styled","Box","Card","props","useDrag","item","card","collect","monitor","isDragging","isDropped","didDrop","opacity","drag","React","useContext","ResponsiveContext","fontSize","css","top","left","cardBackgroundColor","backgroundColor","style","ref","align","elevation","hoverIndicator","CardSection","boxes","key","direction","gap","justify","wrap","margin","DropZone","div","CategoriesDropTarget","dropTargetRef","useRef","useState","filter","x","Categories","setBoxes","useDrop","accept","isOver","canDrop","hover","delta","getClientOffset","console","log","y","drop","current","offsetLeft","offsetTop","boxList","length","box","push","moveBox","cardBoxes","fill","CategoriesSection","categoryBoxes","c","title","width","description","StyledBox","CardSort","store","getState","configuration","DndProvider","backend","Backend","ColorBoardStore","colorIndex","columns","rows","Responsive","columnsVal","rowsVal","Grid","justifyContent","alignContent","padding","children","ColorBoard","listPlanOptionBoxes","onChange","index","ColorCardBox","ColorCard","setColorIndex","onClick","newIndex","skipFirstColorOnCycle","SectionBox","StyledLink","Link","theme","PageRouter","useRouteMatch","path","url","cardSortSection","getCardSorts","triColorBoardSection","getColorBoards","flex","routes","section","configs","cardSortConfig","Instance","links","marginBottom","to","colorBoardConfig","StyledMainBox","App","basename","window","pathname","substr","lastIndexOf","Grommet","full","overflow","horizontal","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4be2d33e.chunk.js","sourcesContent":["import { ThemeType } from \"grommet\";\n\nexport const GlobalTheme: ThemeType = {\n    global: {\n        colors: {\n            MebsDarkBlue: '#78d0bb',\n            MebsLightBlue: '#9befdb',\n            MebsDarkYellow: '#f2dd8c',\n            MebsLightYellow: '#f6e6ab',\n            MebsDarkGray: '#737373',\n            MebsLightGray: '#cbcdca'\n        },\n        font: {\n            family: 'Helvetica',\n            size: '14px',\n            height: '20px',\n        },\n        breakpoints: {\n            xsmall: {\n                value: 650,\n            },\n            small: {\n                value: 950\n            },\n            medium: {\n                value: 1300\n            },\n            large: {\n                value: 1600\n            },\n            xlarge: {\n                value: 3000\n            }\n        },\n        focus: {\n            border: {\n                color: '#f2dd8c'\n            },\n\n        }\n    },\n    button: {\n        active: {\n            default: {\n                border: {\n                    color: 'red'\n                }\n            },\n            primary: {\n                border: {\n                    color: 'red'\n                }\n            },\n            secondary: {\n                border: {\n                    color: 'red'\n                }\n            }\n        }\n    }\n};\n\ntype Sizes = ('xsmall' | 'small' | 'medium' | 'large' | 'xlarge');\nexport function getGridBoxWidth(size: Sizes) {\n\n    var x = GlobalTheme!.global!.breakpoints![size];\n    return x;\n}","import { BaseConfig, BaseStore } from \"./BaseStore\";\n\nexport interface CardSortConfig extends BaseConfig {\n    cardBackgroundColor?: string;\n    cards: CardSortCardConfig[];\n    categories: CardSortCategoryConfig[];\n}\n\nexport interface CardSortCardConfig {\n    text: string;\n}\nexport interface CardSortCategoryConfig {\n    title: string;\n    description: string;\n}\n\n\nexport interface CardData {\n    type: string\n    id: string\n    top?: number\n    left?: number,\n    location: CardLocation\n}\n\nexport interface CardCategoryData {\n    title: string,\n    description: string\n};\n\n\nexport enum CardLocation { List, Categories };\n\nexport interface CardSortState {\n    cards: CardData[];\n    categories: CardCategoryData[];\n}\n\nexport class CardSortStore implements BaseStore<CardSortConfig, CardSortState> {\n    private static instance: CardSortStore = new CardSortStore();\n    public static get Instance() {\n        return CardSortStore.instance;\n    }\n\n    stateMap: Map<string, CardSortState> = new Map();\n\n    public getState(config: CardSortConfig) {\n        if (this.stateMap.has(config.name)) {\n            return this.stateMap.get(config.name)!;\n        }\n        else {\n\n            const cards: CardData[] = config.cards.map((s) => { return { id: s.text, type: \"card\", location: CardLocation.List } });\n            const categories: CardCategoryData[] = config.categories;\n            const state: CardSortState = { cards, categories };\n            this.stateMap.set(config.name, state);\n            return state;\n        }\n    }\n}","import React, { useState } from \"react\";\nimport { Box, ResponsiveContext } from \"grommet\";\nimport styled from \"styled-components\";\nimport { useDrag, useDrop, DndProvider } from 'react-dnd';\nimport Backend from 'react-dnd-html5-backend';\nimport { CardSortStore, CardData, CardLocation, CardCategoryData, CardSortConfig } from \"../stores/cardSortStore\";\n\n\nconst StyledCard = styled(Box)`\nbackground-color: lightblue;\nborder: 1px solid #000;\npadding:5px;\ncursor: move;\nwidth: 150px;\ndisplay: inline-block;\nborder-radius:10px;`;\n\ntype CardProps = { card: CardData, location: CardLocation, config: CardSortConfig };\nconst Card: React.FC<CardProps> = (props: CardProps): JSX.Element => {\n    const [{ opacity, isDragging, isDropped }, drag] = useDrag({\n        item: props.card,\n        collect: (monitor) => ({\n            isDragging: monitor.isDragging(),\n            isDropped: monitor.didDrop(),\n            opacity: monitor.isDragging() ? 0.4 : 1,\n        })\n    })\n\n\n    const size = React.useContext(ResponsiveContext);\n    let fontSize = \"inherit\";\n    if (size === \"small\") {\n        fontSize = \"11px\";\n    }\n    else if (size === \"xsmall\") {\n        fontSize = \"9px\";\n    }\n\n    if (isDragging || isDropped || props.location !== props.card.location) {\n        return <div />;\n    }\n\n    let css: React.CSSProperties = { opacity, fontSize, \"top\": props.card.top, \"left\": props.card.left, \"position\": props.card.left ? \"absolute\" : \"static\" };\n    if (props.config.cardBackgroundColor) {\n        css.backgroundColor = props.config.cardBackgroundColor;\n    }\n\n    return <StyledCard style={css}\n        ref={drag}\n        align=\"center\"\n        elevation=\"small\"\n        hoverIndicator>\n        <h3>{props.card.id}</h3>\n    </StyledCard>;\n}\n\ntype CardSortInternalProps = { cards: CardData[], categories: CardCategoryData[], config: CardSortConfig };\nconst CardSection: React.FC<CardSortInternalProps> = (props) => {\n    var boxes = props.cards.map(s => {\n        return <Card key={s.id} card={s} config={props.config} location={CardLocation.List} />;\n    });\n    return <Box height=\"40%\" direction=\"row\" align=\"center\" gap=\"medium\" justify=\"center\" wrap margin={{ \"bottom\": \"70px\" }} >\n        {boxes}\n    </Box>;\n};\n\nconst DropZone = styled.div`\ndisplay:block;\nposition: relative;\nwidth: 100%;\nheight: 100%;\n`;\nconst CategoriesDropTarget: React.FC<CardSortInternalProps> = (props): JSX.Element => {\n    const dropTargetRef = React.useRef<HTMLDivElement>(null);\n    const [boxes, setBoxes] = useState<CardData[]>(props.cards.filter(x => x.location === CardLocation.Categories));\n    const moveBox = (item: CardData) => {\n\n        let boxList = boxes.filter(x => x.id === item.id);\n        if (boxList != null && boxList.length > 0) {\n            const box = boxList[0];\n            box.left = item.left;\n            box.top = item.top;\n        } else {\n            boxes.push(item);\n        }\n        setBoxes(boxes);\n    }\n\n\n    const [{ canDrop, isOver }, drop] = useDrop({\n        accept: \"card\",\n        collect: (monitor) => ({\n            isOver: monitor.isOver(),\n            canDrop: monitor.canDrop()\n        }),\n        hover(item: CardData, monitor) {\n            const delta = monitor.getClientOffset();\n            if (delta) {\n                console.log(`x:${delta.x}, y:${delta.y})`);\n            }\n        },\n        drop(item: CardData, monitor) {\n            item.location = CardLocation.Categories;\n            const delta = monitor.getClientOffset();\n            if (delta !== null && dropTargetRef.current) {\n                item.left = delta.x - dropTargetRef.current.offsetLeft;\n                item.top = delta.y - dropTargetRef.current.offsetTop;\n\n                moveBox(item);\n            }\n            return undefined\n        },\n    });\n    const isActive = canDrop && isOver\n    let backgroundColor = 'transparent';\n    if (isActive) {\n        backgroundColor = 'transparent';\n    } else if (canDrop) {\n        backgroundColor = 'transparent';\n    }\n\n    var cardBoxes = boxes.map(x => {\n        return <Card key={x.id} card={x} location={CardLocation.Categories} config={props.config} />\n    });\n\n    return (\n        <Box style={{ backgroundColor }} fill ref={dropTargetRef}>\n            <DropZone ref={drop}>\n                <CategoriesSection {...props} />\n                {cardBoxes}\n            </DropZone>\n        </Box >\n    )\n}\n\nconst CategoriesSection: React.FC<CardSortInternalProps> = (props) => {\n    var categoryBoxes = props.categories.map(c => <Box key={c.title} width=\"33%\">\n        <h1>{c.title}</h1>\n        <span>{c.description}</span>\n    </Box>);\n    return <Box height=\"auto\" direction=\"row\" align=\"stretch\" gap=\"large\">\n        {categoryBoxes}\n    </Box>;\n};\n\nconst StyledBox = styled(Box)`\n  padding-left:15px;\n  padding-right:15px;\n`;\n\nexport type CardSortProps = {\n    configuration: CardSortConfig\n    store: CardSortStore\n}\n\nexport const CardSort: React.FC<CardSortProps> = (props: CardSortProps) => {\n\n    const state = props.store.getState(props.configuration);\n    return <DndProvider backend={Backend}>\n        <StyledBox direction=\"column\" align=\"center\" fill>\n            <h1>{props.configuration.title}</h1>\n            <CardSection cards={state.cards} categories={state.categories} config={props.configuration} />\n            <CategoriesDropTarget cards={state.cards} categories={state.categories} config={props.configuration} />\n        </StyledBox>\n    </DndProvider>;\n};\n\n","import { BaseConfig, BaseStore } from \"./BaseStore\";\n\nexport interface ColorBoardConfig extends BaseConfig {\n    colors: string[];\n    cards: ColorBoardCardConfig[];\n    skipFirstColorOnCycle?: boolean;\n}\n\nexport interface ColorBoardCardConfig {\n    text: string;\n}\n\ninterface ColorBoardCardData extends ColorBoardCardConfig {\n    colorIndex: number;\n};\n\nexport interface ColorBoardState {\n    cards: ColorBoardCardData[];\n}\n\nexport class ColorBoardStore implements BaseStore<ColorBoardConfig, ColorBoardState> {\n\n    private static instance: ColorBoardStore = new ColorBoardStore();\n    public static get Instance() {\n        return ColorBoardStore.instance;\n    }\n\n    stateMap: Map<string, ColorBoardState> = new Map();\n\n    public getState(config: ColorBoardConfig) {\n        if (this.stateMap.has(config.name)) {\n            return this.stateMap.get(config.name)!;\n        }\n        else {\n            const cards: ColorBoardCardData[] = config.cards.map((s) => { return { ...s, colorIndex: 0 } });\n            const state: ColorBoardState = { cards };\n            this.stateMap.set(config.name, state);\n            return state;\n        }\n    }\n}","import React, { useState } from \"react\";\nimport { Box, Grid, ResponsiveContext, GridProps } from \"grommet\";\nimport styled from \"styled-components\";\nimport { ColorBoardConfig, ColorBoardStore } from \"../stores/colorBoardStore\";\n\ninterface IDictionary<TValue> {\n    [id: string]: TValue;\n}\n// If the size is small, we only see 1 column\n// If the size is medium, we only see 2 columns\n// If the size is either large or xlarge, we see 3 columns\nconst columns: IDictionary<string[]> = {\n    xsmall: [\"auto\"],\n    small: [\"auto\", \"auto\"],\n    medium: [\"auto\", \"auto\", \"auto\"],\n    large: [\"auto\", \"auto\", \"auto\", \"auto\", \"auto\", \"auto\"],\n    xlarge: [\"auto\", \"auto\", \"auto\", \"auto\", \"auto\", \"auto\"]\n};\n\n// If the size is small, we have 3 rows\n// If the size is medium, we have 2 rows\n// If the size is large or xlarge, we have 1 row\nconst rows: IDictionary<string[]> = {\n    small: [\"xsmall\", \"xsmall\", \"xsmall\"],\n    medium: [\"xsmall\", \"xsmall\"],\n    large: [\"xsmall\"],\n    xlarge: [\"xsmall\"]\n};\n\ntype ResponsiveGridProps = { size: string, children: any } & GridProps;\nconst Responsive = (props: ResponsiveGridProps) => {\n    const size = props.size;\n    // Take into consideration if not array is sent but a simple string\n    let columnsVal: (string[] | null) = null;\n    if (columns) {\n        if (columns[size]) {\n            columnsVal = columns[size];\n        }\n    }\n\n    let rowsVal: (string[] | null) = null;\n    if (rows) {\n        if (rows[size]) {\n            rowsVal = rows[size];\n        }\n    }\n\n    return (\n        <Grid\n            justifyContent=\"center\"\n            alignContent=\"stretch\"\n            align=\"center\"\n            justify=\"center\"\n            style={{ backgroundColor: '#fff', padding: '1px' }}\n            rows={!rowsVal ? size : rowsVal}\n            columns={!columnsVal ? size : columnsVal}\n            {...props}>\n            {props.children}\n        </Grid>\n    );\n}\n\nexport type ColorBoardProps = {\n    configuration: ColorBoardConfig\n    store: ColorBoardStore\n}\n\nexport const ColorBoard: React.FC<ColorBoardProps> = (props: ColorBoardProps) => {\n\n    const state = props.store.getState(props.configuration);\n    const size = React.useContext(ResponsiveContext);\n    // Create box for each  choice\n    const listPlanOptionBoxes = state.cards.map(card => {\n        const onChange = (index: number) => {\n            card.colorIndex = index;\n        }\n        return <ColorCard key={card.text} text={card.text} colorIndex={card.colorIndex} config={props.configuration} onChange={onChange} />\n    });\n\n    return <Box>\n        <Responsive size={size} fill={true} gap=\"0px\" margin=\"0px\" rows=\"auto\">\n            {listPlanOptionBoxes}\n        </Responsive>\n    </Box>\n};\n\nexport type ColorCardProps = {\n    text: string,\n    colorIndex: number,\n    config: ColorBoardConfig,\n    onChange?: (index: number) => void\n}\n\ninterface BoxProps {\n    backgroundColor: string;\n}\nconst ColorCardBox = styled.div<BoxProps>`\nbackground-color: ${props => props.backgroundColor || \"white\"};\nborder: 0.5px solid #000;\nborder-radius:0;\ntext-align: center;\npadding: 15px;\nwidth: 200px;\nheight: 70px;\nalign-items: center;\ndisplay: flex;\nline-height: normal;\nfont-size: 1.1rem;\njustify-content: center;    \n-webkit-touch-callout: none;\n-webkit-user-select: none;\n-khtml-user-select: none;\n-moz-user-select: none;\n-ms-user-select: none;\nuser-select: none;\ncolor: black;`;\n\n\nconst ColorCard = (props: ColorCardProps) => {\n\n    const [colorIndex, setColorIndex] = useState(props.colorIndex);\n\n    const onClick = () => {\n        let newIndex = (colorIndex + 1) % props.config.colors.length;\n\n        if (props.config.skipFirstColorOnCycle && newIndex === 0) {\n            newIndex++;\n        }\n\n        setColorIndex(newIndex);\n\n        if (props.onChange) {\n            props.onChange(newIndex);\n        }\n    }\n\n    let backgroundColor = props.config.colors[colorIndex];\n\n    return <ColorCardBox key={props.text} backgroundColor={backgroundColor} onClick={onClick} >\n        <span>{props.text}</span>\n    </ColorCardBox>;\n}","import React from \"react\";\nimport { CardSort } from \"./CardSort\";\nimport { Switch, Route, Link, useRouteMatch } from \"react-router-dom\";\nimport { Box } from \"grommet\";\nimport styled from \"styled-components\";\nimport { CardSortStore, CardSortConfig } from \"../stores/cardSortStore\";\n\n\n// Config files\nimport cardSortConfig from \"../configurations/cardSortConfig.json\";\n\nimport colorBoardConfig from \"../configurations/colorBoardConfig.json\";\nimport { ColorBoardStore, ColorBoardConfig } from \"../stores/colorBoardStore\";\nimport { ColorBoard } from \"./ColorBoard\";\n\n\nconst StyledBox = styled(Box)`\n`;\n\nconst SectionBox = styled(Box)`\n    width:500px;\n`;\n\nconst StyledLink = styled(Link)`\n  font-weight: bold;\n  text-decoration: none;\n  font-size: 17px;\n  color: ${props => props.theme.global.colors['neutral-3']};\n  &:active, &:visited {\n    color: ${props => props.theme.global.colors['neutral-3']};\n    border: none;\n  }\n  &:hover {\n    color: ${props => props.theme.global.colors['neutral-4']};\n  }\n`;\n\nexport const PageRouter = () => {\n\n    let { path, url } = useRouteMatch();\n\n    const cardSortSection = getCardSorts(path, url);\n    \n    const triColorBoardSection = getColorBoards(path, url);\n    \n\n    return (\n        <StyledBox fill={true} flex align='center'  >\n            <Switch>\n                \n                {cardSortSection.routes}\n                {triColorBoardSection.routes}\n                \n                <Route path=\"/\">\n                    <h1>Directory of Tools</h1>\n                    \n                    {cardSortSection.section}\n                    {triColorBoardSection.section}\n                    \n                </Route>\n            </Switch></StyledBox>);\n}\n\n\nexport interface PageSections {\n    section?: JSX.Element;\n    routes?: JSX.Element[];\n}\n\nconst getCardSorts = (path: string, url: string) => {\n    const configs: CardSortConfig[] = cardSortConfig;\n    if (!configs || configs.length <= 0) {\n        return {};\n    }\n    const routes = configs.map(x => <Route key={x.name} path={`${path}${x.name}`}>\n        <CardSort configuration={x} store={CardSortStore.Instance} />\n    </Route>);\n\n    const links = configs.map(x => <li style={{ marginBottom: '8px' }} key={x.name}><StyledLink key={x.name} to={`${url}${x.name}`}>\n        {x.title}\n    </StyledLink></li>);\n\n    const section = <SectionBox><h2>Card Sorts</h2>\n        <ul>\n            {links}\n        </ul>\n    </SectionBox>;\n\n    return { routes, section };\n}\n\n\n\nconst getColorBoards = (path: string, url: string) => {\n    const configs: ColorBoardConfig[] = colorBoardConfig;\n    if (!configs || configs.length <= 0) {\n        return {};\n    }\n    const routes = configs.map(x => <Route key={x.name} path={`${path}${x.name}`}>\n        <ColorBoard configuration={x} store={ColorBoardStore.Instance} />\n    </Route>);\n\n    const links = configs.map(x => <li style={{ marginBottom: '8px' }} key={x.name}><StyledLink key={x.name} to={`${url}${x.name}`}>\n        {x.title}\n    </StyledLink></li>);\n\n    const section = <SectionBox><h2>Color Boards</h2>\n        <ul>\n            {links}\n        </ul>\n    </SectionBox>;\n\n    return { routes, section };\n}\n\n","import React from 'react';\nimport {\n  Box,\n  Grommet\n} from 'grommet';\nimport styled from \"styled-components\";\nimport { GlobalTheme } from './Theme';\nimport {\n  BrowserRouter as Router\n} from \"react-router-dom\";\nimport { PageRouter } from './components/PageRouter';\n\nconst StyledMainBox = styled(Box)`\n  margin-bottom: 10px;\n  margin-top: 0;\n  margin-left:0;\n  margin-right:0;\n  padding-top: 10px;\n`;\n\nconst getBasename = (path: string) => path.substr(0, path.lastIndexOf('/'));\n\nconst App = () => {\n\n  return (\n    <Router basename={getBasename(window.location.pathname)}>\n      <Grommet theme={GlobalTheme} full>\n        <Box fill>\n          <StyledMainBox direction='row' flex overflow={{ horizontal: 'hidden' }}>\n            <Box flex align='center' justify='center'>\n              <PageRouter />\n            </Box>\n          </StyledMainBox>\n        </Box>\n      </Grommet>\n    </Router>\n  );\n\n}\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}